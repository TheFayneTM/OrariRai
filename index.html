<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF → Orario (.ics) — parser definitivo (line-aware)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;max-width:1000px;margin:18px auto;padding:12px}
  h1{margin:0 0 10px;font-size:1.1rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type=text], input[type=file], select {width:100%; padding:8px; box-sizing:border-box}
  button{margin-top:10px;padding:10px 14px;cursor:pointer}
  .small{font-size:0.9rem;color:#444}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border:1px solid #ddd;padding:6px;text-align:left}
  th{background:#f3f3f3}
  .events{margin-top:12px}
  .event{border:1px solid #ddd;padding:8px;margin-bottom:6px;border-radius:6px}
  .override-grid{margin-top:12px}
  .note{margin-top:8px;font-size:0.9rem;color:#333}
  .flex {display:flex; gap:8px}
</style>
</head>
<body>
  <h1>Convertitore PDF → Orario (.ics) — parser definitivo (line-aware)</h1>
  <p class="small">Priorità ai codici tra virgolette, fallback a codici non tra virgolette; ignorati rumori (MNS, MFS, &gt;, 95/96). Ora il parser ricostruisce le righe visive dal PDF per assegnare correttamente la riga al dipendente.</p>

  <label>File PDF</label>
  <input id="pdfFile" type="file" accept="application/pdf" />

  <div class="flex" style="margin-top:8px;">
    <div style="flex:1">
      <label>Nome</label>
      <input id="firstName" type="text" placeholder="es. Antonio" />
    </div>
    <div style="flex:1">
      <label>Cognome</label>
      <input id="lastName" type="text" placeholder="es. Amato" />
    </div>
  </div>

  <div style="margin-top:12px;">
    <button id="parseBtn">Analizza PDF</button>
    <button id="buildBtn" disabled>Genera Calendario (.ics)</button>
  </div>

  <div id="status" class="small" style="margin-top:10px"></div>
  <div id="detected" style="margin-top:12px"></div>
  <div id="overrideArea" class="override-grid"></div>
  <div id="output" style="margin-top:12px"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>
/* =============================
   CONFIGURAZIONE: TURNI CANONICI
   ============================= */
const RAW_SHIFTS = {
  "4O":"05:55-13:30","5O":"05:55-14:30","14":"12:15-20:50","57":"11:25-19:00","5T":"13:00-20:35",
  "6L":"12:00-19:35","B1":"05:50-14:25","C":"07:00-15:35","CE*":"07:00-14:35","D":"08:00-16:35",
  "DE*":"08:00-15:35","E":"08:30-17:05","H":"11:00-19:30","EZ":"10:25-19:00","F":"09:00-17:35",
  "FE*":"09:00-16:35","G":"10:00-18:35","G*":"10:00-17:35","G+":"11:00-18:35","I":"12:45-21:20",
  "I* CO":"12:45-20:20","L":"13:30-22:05","L* CO":"13:30-21:05","L+":"14:30-22:05","2Q":"14:00-22:35",
  "M":"15:00-23:35","M+":"16:00-23:35","N":"15:55-00:30","N1":"16:25-01:00","O":"16:55-01:30",
  "RC":"05:30-14:05","RG":"12:00-20:35","SR":"10:45-19:20","TC":"06:30-15:05","UD":"10:25-18:00",
  "US":"11:30-19:05","VI":"11:30-20:05","RU":"05:00-13:35","XXX":"00:00-00:00"
};
const SHIFT_TIMES = {}; const SHIFT_MAP = {};
Object.keys(RAW_SHIFTS).forEach(k=>{ const up=k.toUpperCase(); SHIFT_TIMES[up]=RAW_SHIFTS[k]; const collapsed=up.replace(/\s+/g,''); SHIFT_MAP[collapsed]=up; SHIFT_MAP[up]=up; });

const STUDIO_MAP = {
  'N1':'Nomentano 1','N2':'Nomentano 2','N3':'Nomentano 3','N4':'Nomentano 4','N5':'Nomentano 5','N6':'Nomentano 6',
  'AFP1':'Foro Italico','1':'Teulada 1','2':'Teulada 2','3':'Teulada 3','4':'Teulada 4','5':'Teulada 5',
  'SR1':'Saxa Rubra 1','SR2':'Saxa Rubra 2','SR3':'Saxa Rubra 3','SR4':'Saxa Rubra 4','SR5':'Saxa Rubra 5',
  'RAN':'Saxa Rubra (Rai News)','AUM':'Montecitorio','DISP':'Disposizione','TDV':'Teatro delle Vittorie','SE':'Servizio Esterno'
};

const IGNORED_TOKENS = new Set(['95','96','MNS','MFS','>','●','--','—']);

/* Utilities */
function setStatus(s){ document.getElementById('status').innerText = s; }
function toICSDateUTC(d){ const Y=d.getUTCFullYear().toString().padStart(4,'0'),M=(d.getUTCMonth()+1).toString().padStart(2,'0'),D=d.getUTCDate().toString().padStart(2,'0'); const h=d.getUTCHours().toString().padStart(2,'0'),m=d.getUTCMinutes().toString().padStart(2,'0'),s=d.getUTCSeconds().toString().padStart(2,'0'); return `${Y}${M}${D}T${h}${m}${s}Z`; }
function download(filename, text){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([text],{type:'text/calendar;charset=utf-8'})); a.download=filename; a.click(); URL.revokeObjectURL(a.href); }
function addMinutes(d,min){ return new Date(d.getTime()+min*60000); }
function parseDDMMYYYY(s){ const [d,m,y]=s.split('/').map(Number); return new Date(y,m-1,d); }
function gcalAddUrl(title,startDate,endDate,desc){ const s=encodeURIComponent(title),d1=toICSDateUTC(startDate),d2=toICSDateUTC(endDate),de=encodeURIComponent(desc||''); return `https://www.google.com/calendar/render?action=TEMPLATE&text=${s}&dates=${d1}/${d2}&details=${de}&ctz=${Intl.DateTimeFormat().resolvedOptions().timeZone}`; }

/* =============================
   Nuova estrazione: ricostruisce le righe usando le y-coordinates di pdf.js
   Restituisce per ogni pagina un array di stringhe (righe nella stessa posizione verticale)
   ============================= */
async function extractPagesAsLines(arrayBuffer){
  const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
  const pdf = await loadingTask.promise;
  const pagesLines = [];
  for(let p=1; p<=pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();
    // content.items: ogni item ha .str e .transform (matrix). 
    // La componente verticale spesso è transform[5] (y). Usiamo round per aggregare vicino valori.
    const byY = {};
    for(const it of content.items){
      const txt = (it.str || '').replace(/\r?\n/g,' ').trim();
      // find y coordinate robustly:
      let y = null;
      if(it.transform && it.transform.length >= 6) y = Math.round(it.transform[5]); 
      else if(it.hasOwnProperty('y')) y = Math.round(it.y);
      else y = 0;
      // group by y (allow slight variations)
      // use bucket size 2 (tolleranza)
      const key = Math.round(y/2)*2;
      if(!byY[key]) byY[key] = [];
      byY[key].push(txt);
    }
    // order by y descending (pdf.js y bigger is up or down depending — we sort by key descending to maintain visual order)
    const keys = Object.keys(byY).map(k=>Number(k)).sort((a,b)=>b-a);
    const lines = keys.map(k => byY[k].join(' ').replace(/\s+/g,' ').trim()).filter(Boolean);
    pagesLines.push(lines);
  }
  return pagesLines;
}

/* Rileva inizio settimana dal testo della pagina (fallback) */
function detectWeekStartFromLines(pagesLines){
  for(const lines of pagesLines){
    for(const ln of lines){
      const m = ln.match(/(\d{2}\/\d{2}\/\d{4})\s+(\d{2}\/\d{2}\/\d{4})/);
      if(m) return parseDDMMYYYY(m[1]);
    }
  }
  return null;
}

/* =============================
   Parser versione "riga-visiva aware" (modalità C)
   Cerco la riga esatta che contiene il nome; su quella riga applico la logica dei 'codici' e dei token.
   ============================= */
function parsePersonRowPerDayFromLines(pagesLines, rawFirst, rawLast){
  const first = (rawFirst||'').toUpperCase().trim();
  const last = (rawLast||'').toUpperCase().trim();
  const searches = [];
  if(first && last){
    searches.push(`${last}, ${first}`); searches.push(`${first} ${last}`); searches.push(`${last} ${first}`);
  } else {
    const combined = (rawFirst + ' ' + rawLast).trim();
    const parts = combined.split(/\s+/).map(s=>s.toUpperCase()).filter(Boolean);
    if(parts.length>=2){ searches.push(`${parts[1]}, ${parts[0]}`); searches.push(`${parts[0]} ${parts[1]}`); searches.push(`${parts[1]} ${parts[0]}`); }
    else searches.push(combined.toUpperCase());
  }

  // Scorri pagine e righe
  for(const lines of pagesLines){
    for(let ri=0; ri<lines.length; ri++){
      const line = lines[ri];
      const up = line.toUpperCase();
      // cerco le varianti del nome nella singola riga
      let found = false;
      for(const s of searches){ if(up.indexOf(s) !== -1){ found = true; break; } }
      if(!found) continue;

      // abbiamo la riga corretta: prendila e anche le righe vicine (se i dati sono spezzati su più righe)
      let context = up;
      // includi alcune righe successive se presenti (ad es. studio o OB su riga dopo)
      for(let k=1;k<=2 && ri + k < lines.length;k++) context += ' ' + lines[ri + k].toUpperCase();

      // Ora estrai i codici in modalità C (quoted first)
      const perDay = [];
      for(let i=0;i<7;i++) perDay.push({shift:null, raw:null, studio:'', ob:''});

      // 1) estrai sequenza di valori tra virgolette (in ordine)
      const quoted = [];
      const qRegex = /'([^']+)'/g;
      let m;
      while((m = qRegex.exec(context)) !== null){
        if(m[1]) quoted.push(m[1].trim());
      }

      // 2) tokenizzazione di fallback dalla sola context string (rimuoviamo virgolette)
      const fallbackTokens = context.replace(/['"]/g,' ').split(/[\s]+/).map(t=>t.replace(/^[,.;:]+|[,.;:]+$/g,'').trim()).filter(Boolean);

      // Fill from quoted, left-to-right, assigning sequentialmente Lun→Dom
      let qCursor = 0;
      for(let d=0; d<7 && qCursor < quoted.length; d++){
        let rawQ = quoted[qCursor++].toUpperCase();
        // in rawQ possono esserci prefissi MNS etc; estrai candidati alfanumerici/symbol
        const parts = rawQ.split(/[^A-Z0-9\*\+\s]/i).map(p=>p.trim()).filter(Boolean);
        let foundShift = null;
        for(let pi=parts.length-1; pi>=0; pi--){
          const candidate = parts[pi].replace(/\s+/g,'').toUpperCase();
          if(!candidate) continue;
          if(/^OB\d+$/i.test(candidate)){ perDay[d].ob = candidate.toUpperCase(); continue; }
          const mapped = SHIFT_MAP[candidate] || SHIFT_MAP[candidate.replace(/\s+/g,'')];
          if(mapped){ foundShift = mapped; break; }
          // studio?
          if(STUDIO_MAP[candidate]) perDay[d].studio = STUDIO_MAP[candidate];
        }
        if(foundShift){ perDay[d].shift = foundShift; perDay[d].raw = rawQ; }
      }

      // If some days still empty, scan fallbackTokens left-to-right after the name occurrence and fill remaining
      let dayCursor = 0; while(dayCursor<7 && perDay[dayCursor].shift) dayCursor++;
      for(let ti=0; ti<fallbackTokens.length && dayCursor<7; ti++){
        const tok = fallbackTokens[ti].toUpperCase();
        if(!tok) continue;
        if(IGNORED_TOKENS.has(tok)) continue;
        if(/^OB\d+$/i.test(tok)){ if(!perDay[dayCursor].ob){ perDay[dayCursor].ob = tok; continue; } if(dayCursor>0 && !perDay[dayCursor-1].ob){ perDay[dayCursor-1].ob = tok; continue; } continue; }
        const tokCollapsed = tok.replace(/\s+/g,'');
        // studio?
        if(STUDIO_MAP[tok] || STUDIO_MAP[tokCollapsed]){
          const sname = STUDIO_MAP[tok] || STUDIO_MAP[tokCollapsed];
          if(!perDay[dayCursor].studio) perDay[dayCursor].studio = sname;
          continue;
        }
        // try shift mapping
        let matchKey = SHIFT_MAP[tok] || SHIFT_MAP[tokCollapsed];
        if(!matchKey){
          const cleaned = tok.replace(/[^A-Z0-9\*\+]/g,'');
          matchKey = SHIFT_MAP[cleaned];
        }
        if(matchKey){
          perDay[dayCursor].shift = matchKey; perDay[dayCursor].raw = tok;
          // lookahead for studio/ob in nearby tokens
          for(let la=1; la<=6 && (ti+la) < fallbackTokens.length; la++){
            const t2 = fallbackTokens[ti+la].toUpperCase().replace(/^[,.;:]+|[,.;:]+$/g,'').trim();
            if(!t2) continue;
            if(/^OB\d+$/i.test(t2) && !perDay[dayCursor].ob) perDay[dayCursor].ob = t2;
            const t2c = t2.replace(/\s+/g,'');
            if(!perDay[dayCursor].studio && (STUDIO_MAP[t2] || STUDIO_MAP[t2c])) perDay[dayCursor].studio = STUDIO_MAP[t2] || STUDIO_MAP[t2c];
            if(perDay[dayCursor].studio && perDay[dayCursor].ob) break;
          }
          dayCursor++; while(dayCursor<7 && perDay[dayCursor].shift) dayCursor++;
        }
      }

      // Clean invalid shifts (95/96)
      for(let i=0;i<7;i++){ const s = perDay[i].shift; if(!s) continue; if(s==='95' || s==='96'){ perDay[i].shift = null; perDay[i].raw = null; } }

      if(perDay.some(d=>d.shift)) return perDay;
      // else keep cercando altre righe
    }
  }
  return null;
}

/* Build events e ICS (uguale a prima) */
function buildEvents(startDate, perDay, personName){
  const evs = [];
  for(let i=0;i<7;i++){
    const d = perDay[i] || {};
    if(!d.shift) continue;
    const key = d.shift.toUpperCase();
    const time = SHIFT_TIMES[key];
    if(!time) continue;
    if(time === "00:00-00:00") continue;
    const [s,e] = time.split('-').map(t=>t.trim());
    const day = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + i);
    const [sh, sm] = s.split(':').map(Number);
    const [eh, em] = e.split(':').map(Number);
    const start = new Date(day.getFullYear(), day.getMonth(), day.getDate(), sh, sm);
    let end = new Date(day.getFullYear(), day.getMonth(), day.getDate(), eh, em);
    if(end <= start) end = addMinutes(end, 24*60);
    const studioName = d.studio || (STUDIO_MAP[d.shift] || '') || '';
    const ob = d.ob || '';
    const parts = [d.shift];
    if(studioName) parts.push(studioName);
    if(ob) parts.push(ob.toUpperCase());
    const title = parts.join(' — ');
    const desc = `Turno: ${d.shift}\nOrario: ${s} - ${e}${studioName?`\nStudio: ${studioName}`:''}${ob?`\nOB: ${ob}`:''}`;
    evs.push({title, start, end, desc, location: studioName});
  }
  return evs;
}
function buildICS(events){
  const lines = ['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//PDF→Orario//v2'];
  events.forEach((ev,i)=>{ lines.push('BEGIN:VEVENT'); lines.push(`UID:${Date.now()}-${i}@pdf-orario`); lines.push(`DTSTAMP:${toICSDateUTC(new Date())}`); lines.push(`DTSTART:${toICSDateUTC(ev.start)}`); lines.push(`DTEND:${toICSDateUTC(ev.end)}`); lines.push(`SUMMARY:${ev.title}`); if(ev.desc) lines.push(`DESCRIPTION:${ev.desc.replace(/\n/g,'\\n')}`); if(ev.location) lines.push(`LOCATION:${ev.location}`); lines.push('END:VEVENT'); });
  lines.push('END:VCALENDAR'); return lines.join('\r\n');
}

/* UI flow */
let lastPagesLines = null, lastPerDay = null, lastWeekStart = null;

document.getElementById('parseBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('pdfFile').files[0];
  const first = (document.getElementById('firstName').value || '').trim();
  const last = (document.getElementById('lastName').value || '').trim();
  if(!f){ alert('Seleziona un file PDF.'); return; }
  if(!first && !last){ alert('Inserisci Nome o Cognome.'); return; }

  setStatus('Lettura PDF e ricostruzione righe (pdf.js)...');
  const ab = await f.arrayBuffer();
  let pagesLines = [];
  try{ pagesLines = await extractPagesAsLines(ab); } catch(e){ console.error(e); setStatus('Errore: impossibile estrarre testo. PDF potrebbe essere scannerizzato.'); return; }
  lastPagesLines = pagesLines;
  lastWeekStart = detectWeekStartFromLines(pagesLines);
  if(!lastWeekStart) setStatus('Attenzione: header settimana non trovato (dd/mm/yyyy dd/mm/yyyy). Verrà usata la data odierna come fallback.');

  setStatus('Parsing riga persona (modalità C, line-aware)...');
  const perDay = parsePersonRowPerDayFromLines(pagesLines, first, last);
  lastPerDay = perDay;
  const det = document.getElementById('detected'); det.innerHTML = '';

  if(!perDay){ setStatus('Riga della persona non trovata automaticamente. Prova a inserire "COGNOME, NOME" o verifica che il PDF contenga testo selezionabile.'); document.getElementById('buildBtn').disabled = true; return; }

  // mostra risultati
  const dayNamesIT = ['Lun','Mar','Mer','Gio','Ven','Sab','Dom'];
  let html = `<h3>Turni rilevati (Lun→Dom)</h3><table><thead><tr><th>Giorno</th><th>Turno</th><th>Studio</th><th>OB</th><th>Orario canonico</th></tr></thead><tbody>`;
  for(let i=0;i<7;i++){
    const d = perDay[i] || {};
    const key = d.shift ? d.shift.toUpperCase() : '';
    const collapsed = key.replace(/\s+/g,'');
    const mapped = SHIFT_MAP[collapsed] ? SHIFT_MAP[collapsed] : (SHIFT_MAP[key] ? SHIFT_MAP[key] : null);
    const time = mapped ? (SHIFT_TIMES[mapped] || '') : '';
    html += `<tr><td>${dayNamesIT[i]}</td><td>${d.shift||''}</td><td>${d.studio||''}</td><td>${d.ob||''}</td><td>${time}</td></tr>`;
  }
  html += '</tbody></table>';
  det.innerHTML = html;

  renderOverrideGrid(perDay);
  setStatus('Controlla i turni rilevati e usa la griglia per eventuali correzioni. Poi clicca "Genera Calendario (.ics)".');
  document.getElementById('buildBtn').disabled = false;
});

function renderOverrideGrid(perDay){
  const area = document.getElementById('overrideArea'); area.innerHTML = '<h3>Correzioni giornaliere (opzionali)</h3>';
  const dayNamesIT = ['Lun','Mar','Mer','Gio','Ven','Sab','Dom'];
  const tbl = document.createElement('table'); tbl.innerHTML = `<thead><tr><th>Giorno</th><th>Turno (codice)</th><th>Studio (nome)</th><th>OB (es. OB3)</th></tr></thead>`;
  const tbody = document.createElement('tbody');
  for(let i=0;i<7;i++){
    const d = perDay[i] || {};
    const tr = document.createElement('tr');
    tr.innerHTML = `<td style="width:70px">${dayNamesIT[i]}</td>
      <td><input data-day="${i}" class="override-shift" value="${d.shift||''}" placeholder="Es. 2Q" /></td>
      <td><input data-day="${i}" class="override-studio" value="${d.studio||''}" placeholder="Es. Nomentano 4" /></td>
      <td><input data-day="${i}" class="override-ob" value="${d.ob||''}" placeholder="Es. OB3" /></td>`;
    tbody.appendChild(tr);
  }
  tbl.appendChild(tbody); area.appendChild(tbl);
  area.appendChild(document.createElement('br')); area.appendChild(document.createTextNode('Se non modifichi nulla verranno usati i valori rilevati automaticamente.'));
}

document.getElementById('buildBtn').addEventListener('click', ()=>{
  const first = (document.getElementById('firstName').value || '').trim();
  const last = (document.getElementById('lastName').value || '').trim();
  if(!lastPerDay){ alert('Analizza prima il PDF.'); return; }

  const perDay = [];
  for(let i=0;i<7;i++){
    const s=(document.querySelector(`.override-shift[data-day="${i}"]`).value||'').trim();
    const st=(document.querySelector(`.override-studio[data-day="${i}"]`).value||'').trim();
    const ob=(document.querySelector(`.override-ob[data-day="${i}"]`).value||'').trim();
    if(s){
      const norm=s.toUpperCase(); const coll=norm.replace(/\s+/g,''); const key = SHIFT_MAP[coll] ? SHIFT_MAP[coll] : (SHIFT_MAP[norm] ? SHIFT_MAP[norm] : null);
      const shiftKey = key ? key : s;
      perDay.push({shift: shiftKey, studio: st||'', ob: ob||''});
    } else {
      const base = lastPerDay[i] || {};
      perDay.push({shift: base.shift||null, studio: base.studio||'', ob: base.ob||''});
    }
  }

  const start = lastWeekStart || new Date();
  const events = buildEvents(start, perDay, `${first} ${last}`);
  if(events.length === 0){ setStatus('Nessun evento creato (forse tutti OFF/XXX o codici non validi).'); return; }
  const ics = buildICS(events);
  const out = document.getElementById('output'); out.innerHTML = '';
  const dl = document.createElement('button'); dl.textContent = `Scarica .ics (${events.length} eventi)`; dl.onclick = ()=> download(`${(last||'utente')}_${(first||'utente')}_orario.ics`, ics);
  out.appendChild(dl);
  const list = document.createElement('div'); list.className='events';
  events.forEach(ev=>{ const div=document.createElement('div'); div.className='event'; const s=ev.start.toLocaleString(), e=ev.end.toLocaleString(); div.innerHTML = `<strong>${ev.title}</strong><div class="small">${s} — ${e}</div>${ev.location? `<div class="small">Luogo: ${ev.location}</div>` : '' }<div style="margin-top:6px;"><a target="_blank" href="${gcalAddUrl(ev.title,ev.start,ev.end,ev.desc)}">Aggiungi evento singolo su Google Calendar</a></div>`; list.appendChild(div); });
  out.appendChild(list); setStatus(`Fatto — creati ${events.length} eventi.`);
});
</script>
</body>
</html>
