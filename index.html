<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF → Schedule (Strict shift list + studios + OB)</title>
<style>
  body {font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; max-width:980px; margin:18px auto; padding:12px;}
  h1{margin:0 0 8px 0;font-size:1.1rem}
  label{display:block;margin-top:10px;font-weight:600}
  input[type=text], input[type=file]{width:100%; padding:8px; box-sizing:border-box}
  button{margin-top:10px;padding:10px 14px;cursor:pointer}
  .small{font-size:0.9rem;color:#444}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border:1px solid #ddd;padding:6px;text-align:left}
  th{background:#f3f3f3}
  .events{margin-top:12px}
  .event{border:1px solid #ddd;padding:8px;margin-bottom:6px;border-radius:6px}
</style>
</head>
<body>
  <h1>PDF → Schedule (strict shift list)</h1>
  <p class="small">Upload the PDF, enter First and Last name exactly as in the PDF (or close). The app will detect up to 7 shifts (Mon→Sun) from your row using only the canonical shift codes you gave. Studio names and per-day OB vans are attached to event titles. Download an .ics or add events individually to Google Calendar.</p>

  <label>PDF file</label>
  <input id="pdfFile" type="file" accept="application/pdf" />

  <div style="display:flex; gap:8px; margin-top:8px;">
    <div style="flex:1">
      <label>First name</label>
      <input id="firstName" type="text" placeholder="Marco" />
    </div>
    <div style="flex:1">
      <label>Last name</label>
      <input id="lastName" type="text" placeholder="Natali" />
    </div>
  </div>

  <div style="margin-top:12px;">
    <button id="parseBtn">Parse PDF</button>
    <button id="buildBtn" disabled>Build Calendar (.ics)</button>
  </div>

  <div id="status" class="small" style="margin-top:10px"></div>
  <div id="detected" style="margin-top:10px"></div>
  <div id="output" style="margin-top:12px"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>
/* =========================
   Canonical shifts (from user)
   Keys are stored uppercase, with spaces removed in a helper map as well
   ========================= */
const RAW_SHIFTS = {
  "4O":"05:55-13:30",
  "5O":"05:55-14:30",
  "14":"12:15-20:50",
  "57":"11:25-19:00",
  "5T":"13:00-20:35",
  "6L":"12:00-19:35",
  "B1":"05:50-14:25",
  "C":"07:00-15:35",
  "CE*":"07:00-14:35",
  "D":"08:00-16:35",
  "DE*":"08:00-15:35",
  "E":"08:30-17:05",
  "H":"11:00-19:30",
  "EZ":"10:25-19:00",
  "F":"09:00-17:35",
  "FE*":"09:00-16:35",
  "G":"10:00-18:35",
  "G*":"10:00-17:35",
  "G+":"11:00-18:35",
  "I":"12:45-21:20",
  "I* CO":"12:45-20:20",
  "L":"13:30-22:05",
  "L* CO":"13:30-21:05",
  "L+":"14:30-22:05",
  "2Q":"14:00-22:35",
  "M":"15:00-23:35",
  "M+":"16:00-23:35",
  "N":"15:55-00:30",
  "N1":"16:25-01:00",
  "O":"16:55-01:30",
  "RC":"05:30-14:05",
  "RG":"12:00-20:35",
  "SR":"10:45-19:20",
  "TC":"06:30-15:05",
  "UD":"10:25-18:00",
  "US":"11:30-19:05",
  "VI":"11:30-20:05",
  "RU":"05:00-13:35",
  "XXX":"00:00-00:00"
};

/* Build helper maps:
   - SHIFT_MAP: normalized token (upper + collapsed spaces) -> key in RAW_SHIFTS
   - SHIFT_TIMES: uppercase key -> time string
*/
const SHIFT_TIMES = {};
const SHIFT_MAP = {};
Object.keys(RAW_SHIFTS).forEach(k => {
  const up = k.toUpperCase();
  SHIFT_TIMES[up] = RAW_SHIFTS[k];
  const collapsed = up.replace(/\s+/g,'');
  SHIFT_MAP[collapsed] = up; // map collapsed form to canonical key
  // also map exact uppercase form to itself for tokens that preserve spaces
  SHIFT_MAP[up] = up;
});

/* Studio mapping (hard-coded) */
const STUDIO_MAP = {
  'N1':'Nomentano 1','N2':'Nomentano 2','N3':'Nomentano 3','N4':'Nomentano 4','N5':'Nomentano 5','N6':'Nomentano 6',
  'AFP1':'Foro Italico',
  '1':'Teulada 1','2':'Teulada 2','3':'Teulada 3','4':'Teulada 4','5':'Teulada 5',
  'SR1':'Saxa Rubra 1','SR2':'Saxa Rubra 2','SR3':'Saxa Rubra 3','SR4':'Saxa Rubra 4','SR5':'Saxa Rubra 5',
  'RAN':'Saxa Rubra (Rai News)',
  'AUM':'Montecitorio','DISP':'Disposizione','TDV':'Teatro delle Vittorie','SE':'Servizio Esterno'
};

/* Utilities */
function setStatus(s){ document.getElementById('status').innerText = s; }
function toICSDateUTC(d){
  const Y = d.getUTCFullYear().toString().padStart(4,'0');
  const M = (d.getUTCMonth()+1).toString().padStart(2,'0');
  const D = d.getUTCDate().toString().padStart(2,'0');
  const hh = d.getUTCHours().toString().padStart(2,'0');
  const mm = d.getUTCMinutes().toString().padStart(2,'0');
  const ss = d.getUTCSeconds().toString().padStart(2,'0');
  return `${Y}${M}${D}T${hh}${mm}${ss}Z`;
}
function download(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:'text/calendar;charset=utf-8'}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function addMinutes(d, min){ return new Date(d.getTime() + min*60000); }
function parseDDMMYYYY(s){ const [d,m,y] = s.split('/').map(Number); return new Date(y, m-1, d); }
function gcalAddUrl(title, startDate, endDate, desc){
  const s = encodeURIComponent(title);
  const d1 = toICSDateUTC(startDate);
  const d2 = toICSDateUTC(endDate);
  const de = encodeURIComponent(desc || '');
  return `https://www.google.com/calendar/render?action=TEMPLATE&text=${s}&dates=${d1}/${d2}&details=${de}&ctz=${Intl.DateTimeFormat().resolvedOptions().timeZone}`;
}

/* PDF text extraction (pdf.js) */
async function extractPagesAsText(arrayBuffer){
  const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
  const pdf = await loadingTask.promise;
  const pages = [];
  for(let p=1; p<=pdf.numPages; p++){
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();
    const pageText = content.items.map(i => i.str).join(' ');
    pages.push(pageText);
  }
  return pages;
}

/* Find week start (looks for dd/mm/yyyy dd/mm/yyyy header) */
function detectWeekStart(pages){
  for(const t of pages){
    const m = t.match(/(\d{2}\/\d{2}\/\d{4})\s+(\d{2}\/\d{2}\/\d{4})/);
    if(m) return parseDDMMYYYY(m[1]);
  }
  return null;
}

/* Find person row and parse tokens around it to build a per-day list:
   - For each day, we look for the next token that matches a shift in SHIFT_MAP.
   - After locating a shift token, we scan the immediate tokens after it for:
       * a studio code (one of STUDIO_MAP keys),
       * an OB token like OB1, OB2...
   - If shift is "XXX" (00:00-00:00) we skip creating an event for that day.
*/
function parsePersonRowPerDay(pages, last, first){
  const searchForms = [
    `${last}, ${first}`,
    `${last} ${first}`,
    `${first} ${last}`
  ].map(s => s.toUpperCase());

  for(const pageText of pages){
    const up = pageText.toUpperCase();
    let pos = -1;
    for(const s of searchForms){
      pos = up.indexOf(s);
      if(pos !== -1) break;
    }
    if(pos === -1) continue;

    // take 700 chars after name (should include full row)
    const snippet = up.slice(pos, pos + 800);
    // split into tokens preserving OB and punctuation; trim stray punctuation
    const rawTokens = snippet.split(/[\s]+/).map(t => t.replace(/^[,.;:]+|[,.;:]+$/g,'').trim()).filter(Boolean);

    // find index of the name token in tokens
    let nameIdx = rawTokens.findIndex(tok => tok.includes(last.toUpperCase()) || tok.includes(first.toUpperCase()));
    if(nameIdx === -1) nameIdx = 0;
    const after = rawTokens.slice(nameIdx + 1, nameIdx + 200).map(t => t.replace(/["']/g,'').trim()).filter(Boolean);

    const perDay = [];
    let cursor = 0;
    for(let day=0; day<7; day++){
      // find next shift token
      let shiftToken = null;
      let rawShiftToken = null;
      while(cursor < after.length && shiftToken === null){
        const tok = after[cursor].trim();
        cursor++;
        if(!tok) continue;
        const norm = tok.toUpperCase();
        const collapsed = norm.replace(/\s+/g,'');
        // match exactly: try collapsed form first, then exact uppercase
        let foundKey = null;
        if(SHIFT_MAP[collapsed]) foundKey = SHIFT_MAP[collapsed];
        else if(SHIFT_MAP[norm]) foundKey = SHIFT_MAP[norm];
        // If foundKey exists, that's a valid shift
        if(foundKey){
          shiftToken = foundKey; // canonical key like "2Q" or "I* CO"
          rawShiftToken = tok;
          break;
        }
        // otherwise not a shift token -> skip (studios or OB may appear; also skip numeric dates)
      }

      // if no shift found for this day, leave empty object
      if(!shiftToken){
        perDay.push({});
        continue;
      }

      // after finding shift at current cursor-1, lookahead few tokens to find studio & OB
      let studioFound = '';
      let obFound = '';
      for(let look=0; look<6 && (cursor + look) < after.length; look++){
        const t = after[cursor + look].toUpperCase().replace(/[,.;:]+$/g,'');
        // OB detection
        if(!obFound && /^OB\d+$/i.test(t)) obFound = t;
        // studio detection: exact match to studio keys
        if(!studioFound){
          // try exact and collapsed
          const tcollapsed = t.replace(/\s+/g,'');
          if(STUDIO_MAP[t]) studioFound = STUDIO_MAP[t];
          else if(STUDIO_MAP[tcollapsed]) studioFound = STUDIO_MAP[tcollapsed];
        }
        if(studioFound && obFound) break;
      }

      perDay.push({shift: shiftToken, shiftRaw: rawShiftToken, studio: studioFound, ob: obFound});
    }

    // return perDay if at least one detected
    if(perDay.some(d => d.shift)) return perDay;
    // otherwise continue search on next page
  }
  return null;
}

/* Build events from perDay with canonical times from SHIFT_TIMES and studios/ob applied */
function buildEvents(startDate, perDay, personName){
  const evs = [];
  for(let i=0;i<7;i++){
    const d = perDay[i] || {};
    if(!d.shift) continue;
    const key = d.shift.toUpperCase();
    const time = SHIFT_TIMES[key];
    if(!time) continue;
    if(time === "00:00-00:00") continue; // skip XXX/off
    const [s,e] = time.split('-').map(t=>t.trim());
    if(!(s && e)) continue;
    const day = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + i);
    const [sh, sm] = s.split(':').map(Number);
    const [eh, em] = e.split(':').map(Number);
    const start = new Date(day.getFullYear(), day.getMonth(), day.getDate(), sh, sm);
    let end = new Date(day.getFullYear(), day.getMonth(), day.getDate(), eh, em);
    if(end <= start) end = addMinutes(end, 24*60); // cross-midnight
    const studioName = d.studio || (STUDIO_MAP[d.shift] || '') || '';
    const ob = d.ob || '';
    // title constructing: CODE — Studio Name — OBx
    const parts = [d.shift];
    if(studioName) parts.push(studioName);
    if(ob) parts.push(ob.toUpperCase());
    const title = parts.join(' — ');
    const desc = `Shift for ${personName}\nCode: ${d.shift}\nTime: ${s} - ${e}${studioName ? `\nStudio: ${studioName}` : ''}${ob ? `\nOB: ${ob}` : ''}`;
    evs.push({title, start, end, desc, location: studioName});
  }
  return evs;
}

/* Build ICS string */
function buildICS(events){
  const lines = ['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//PDF→Schedule//strict-shift-v1'];
  events.forEach((ev,i)=>{
    lines.push('BEGIN:VEVENT');
    lines.push(`UID:${Date.now()}-${i}@pdf-schedule`);
    lines.push(`DTSTAMP:${toICSDateUTC(new Date())}`);
    lines.push(`DTSTART:${toICSDateUTC(ev.start)}`);
    lines.push(`DTEND:${toICSDateUTC(ev.end)}`);
    lines.push(`SUMMARY:${ev.title}`);
    if(ev.desc) lines.push(`DESCRIPTION:${ev.desc.replace(/\n/g,'\\n')}`);
    if(ev.location) lines.push(`LOCATION:${ev.location}`);
    lines.push('END:VEVENT');
  });
  lines.push('END:VCALENDAR');
  return lines.join('\r\n');
}

/* UI & flow */
let lastPages = null;
let lastPerDay = null;
let lastWeekStart = null;

document.getElementById('parseBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('pdfFile').files[0];
  const first = (document.getElementById('firstName').value || '').trim();
  const last = (document.getElementById('lastName').value || '').trim();
  if(!f){ alert('Choose a PDF file'); return; }
  if(!first || !last){ alert('Enter first and last name'); return; }

  setStatus('Reading PDF...');
  const ab = await f.arrayBuffer();
  let pages = [];
  try{
    pages = await extractPagesAsText(ab);
  }catch(err){
    console.error(err);
    setStatus('PDF parsing failed. Make sure the PDF contains selectable text (not only images).');
    return;
  }
  lastPages = pages;
  setStatus('Detecting week start & parsing person row...');
  lastWeekStart = detectWeekStart(pages);
  if(!lastWeekStart){ setStatus('Warning: could not detect week header (dd/mm/yyyy dd/mm/yyyy). The app still attempts to parse row, but dates may be incorrect.'); }
  const perDay = parsePersonRowPerDay(pages, last.toUpperCase(), first.toUpperCase());
  lastPerDay = perDay;
  const det = document.getElementById('detected');
  det.innerHTML = '';
  if(!perDay){
    setStatus('Could not parse person row automatically. Try changing name format to EXACT "LASTNAME, FIRSTNAME" or ensure PDF text is selectable.');
    document.getElementById('buildBtn').disabled = true;
    return;
  }
  // show detected mon->sun
  const dayNames = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
  let html = `<table><thead><tr><th>Day</th><th>Shift</th><th>Studio</th><th>OB</th><th>Time (canonical)</th></tr></thead><tbody>`;
  for(let i=0;i<7;i++){
    const d = perDay[i] || {};
    const key = d.shift ? d.shift.toUpperCase() : '';
    const collapsed = key.replace(/\s+/g,'');
    const mapped = SHIFT_MAP[collapsed] ? SHIFT_MAP[collapsed] : (SHIFT_MAP[key] ? SHIFT_MAP[key]: null);
    const time = mapped ? (SHIFT_TIMES[mapped] || '') : '';
    html += `<tr><td>${dayNames[i]}</td><td>${d.shift || ''}</td><td>${d.studio || ''}</td><td>${d.ob || ''}</td><td>${time}</td></tr>`;
  }
  html += '</tbody></table>';
  det.innerHTML = html;
  setStatus('Parsed person row. Review detected shifts above. If correct, click "Build Calendar" to generate .ics.');
  document.getElementById('buildBtn').disabled = false;
});

document.getElementById('buildBtn').addEventListener('click', ()=>{
  const first = (document.getElementById('firstName').value || '').trim();
  const last = (document.getElementById('lastName').value || '').trim();
  if(!lastPerDay) { alert('Parse PDF first'); return; }
  const start = lastWeekStart || new Date(); // fallback today if not detected
  const events = buildEvents(start, lastPerDay, `${first} ${last}`);
  if(events.length === 0){ setStatus('No events created (maybe all days are XXX/off or mapping missing).'); return; }
  const ics = buildICS(events);
  const out = document.getElementById('output');
  out.innerHTML = '';
  const dl = document.createElement('button');
  dl.textContent = `Download .ics (${events.length} events)`;
  dl.onclick = ()=> download(`${last}_${first}_schedule.ics`, ics);
  out.appendChild(dl);

  const list = document.createElement('div'); list.className='events';
  events.forEach(ev=>{
    const div = document.createElement('div'); div.className='event';
    const s = ev.start.toLocaleString(); const e = ev.end.toLocaleString();
    div.innerHTML = `<strong>${ev.title}</strong><div class="small">${s} — ${e}</div>
                     ${ev.location? `<div class="small">Location: ${ev.location}</div>`: ''}
                     <div style="margin-top:6px;"><a target="_blank" href="${gcalAddUrl(ev.title, ev.start, ev.end, ev.desc)}">Add single event to Google Calendar</a></div>`;
    list.appendChild(div);
  });
  out.appendChild(list);
  setStatus(`Done — ${events.length} events created.`);
});
</script>
</body>
</html>
